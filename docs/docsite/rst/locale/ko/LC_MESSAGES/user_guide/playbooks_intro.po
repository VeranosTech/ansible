# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2013-2018 Ansible, Inc
# This file is distributed under the same license as the Ansible
# Documentation package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Ansible Documentation 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-08-30 11:08+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../rst/user_guide/playbooks_intro.rst:2
msgid "Intro to Playbooks"
msgstr "플레이북 소개"

#: ../../rst/user_guide/playbooks_intro.rst:11
msgid "About Playbooks"
msgstr "플레이북에 대해서"

#: ../../rst/user_guide/playbooks_intro.rst:13
msgid ""
"Playbooks are a completely different way to use ansible than in ad-hoc "
"task execution mode, and are particularly powerful."
msgstr "플레이북은 임시변통으로 작업을 실행하는 것과 전혀 다른 방법이고 훨씬 강력하다. "

#: ../../rst/user_guide/playbooks_intro.rst:16
msgid ""
"Simply put, playbooks are the basis for a really simple configuration "
"management and multi-machine deployment system, unlike any that already "
"exist, and one that is very well suited to deploying complex "
"applications."
msgstr ""
"간단히 말하면, 플레이북은 간단한 설정 관리와 복수 머신 배포 시스템의 기반이 되며 동시에 복잡한 애플리케이션을 배포하는데도 "
"적합하다. "

#: ../../rst/user_guide/playbooks_intro.rst:19
msgid ""
"Playbooks can declare configurations, but they can also orchestrate steps"
" of any manual ordered process, even as different steps must bounce back "
"and forth between sets of machines in particular orders.  They can launch"
" tasks synchronously or asynchronously."
msgstr ""
"플레이북은 설정을 선언하고 여러대의 머신에서 특정한 순서로 서로 다른 작업들이 왔다갔다 하는 경우에도 작업 절차를 조율할 수 있다."
" 또 작업을 동시에 실행할 수도 있고 순차적으로 실행할 수도 있다. "

#: ../../rst/user_guide/playbooks_intro.rst:24
msgid ""
"While you might run the main ``/usr/bin/ansible`` program for ad-hoc "
"tasks, playbooks are more likely to be kept in source control and used to"
" push out your configuration or assure the configurations of your remote "
"systems are in spec."
msgstr ""
"임시변통 작업을 위해 ``/usr/bin/ansible`` 프로그램을 실행하는 경우에는 플레이북을 소스코드 제어 시스템에 보관하고 "
"각각의 경우에 따라 꺼내 쓸 수 있다. "

#: ../../rst/user_guide/playbooks_intro.rst:29
msgid ""
"There are also some full sets of playbooks illustrating a lot of these "
"techniques in the `ansible-examples repository "
"<https://github.com/ansible/ansible-examples>`_.  We'd recommend looking "
"at these in another tab as you go along."
msgstr ""
"`앤서블 예제 레포 <https://github.com/ansible/ansible-examples>`_\\ 에는 이런 기법을 "
"설명하는 플레이북들이 있다. 문서를 읽으면서 같이 이 플레이북도 같이 보기를 권한다."

#: ../../rst/user_guide/playbooks_intro.rst:33
msgid ""
"There are also many jumping off points after you learn playbooks, so hop "
"back to the documentation index after you're done with this section."
msgstr "플레이북을 익힌다음에는 여러가지 주제로 건너갈 수 있다. 따라서 이 절을 일고 다시 문서 색인을 살펴보라. "

#: ../../rst/user_guide/playbooks_intro.rst:39
msgid "Playbook Language Example"
msgstr "플레이북 언어 예제"

#: ../../rst/user_guide/playbooks_intro.rst:41
msgid ""
"Playbooks are expressed in YAML format (see :ref:`yaml_syntax`) and have "
"a minimum of syntax, which intentionally tries to not be a programming "
"language or script, but rather a model of a configuration or a process."
msgstr ""
"플레이북은 YAML 포맷(:ref:`yaml_syntax` 참조)으로 되어 있다. 프로그래밍 언어나 스크립트라기 보다는 설정이나 "
"프로세스를 모형화하기 위한 것이므로 문법이 간단하다. "

#: ../../rst/user_guide/playbooks_intro.rst:45
msgid ""
"Some editors have add-ons that can help you write clean YAML syntax in "
"your playbooks. See :ref:`other_tools_and_programs` for details."
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:48
msgid "Each playbook is composed of one or more 'plays' in a list."
msgstr "각 플레이북은 하나 이상의 '플레이' 리스트로 구성된다. "

#: ../../rst/user_guide/playbooks_intro.rst:50
#, fuzzy
msgid ""
"The goal of a play is to map a group of hosts to some well defined roles,"
" represented by things ansible calls tasks.  At a basic level, a task is "
"nothing more than a call to an ansible module."
msgstr ""
"플레이의 목표는 호스트 그룹에 특정한 역할(role)을 부여하는 것이다. 역할은 앤서블이 작업이라고 부는 것들을 나타낸다. 가장 "
"간단한 작업은 하나의 앤서블 모듈(:doc:`modules`)을 호출하는 것이다."

#: ../../rst/user_guide/playbooks_intro.rst:54
msgid ""
"By composing a playbook of multiple 'plays', it is possible to "
"orchestrate multi-machine deployments, running certain steps on all "
"machines in the webservers group, then certain steps on the database "
"server group, then more commands back on the webservers group, etc."
msgstr ""
"여러개의 플레이를 하나의 플레이북에 조함함으로써 여러대의 머신에 대한 배포를 조율할 수 있다. 예를 들어 웹서버 그룹에 있는 모든 "
"머신에 대해 특정한 단계의 작업을 돌린 다음 데이터베이스 서버 그룹에 대해 또다른 특정 작업을 하고 또 다시 웹서버 그룹에 대해 "
"작업할 수 있다. "

#: ../../rst/user_guide/playbooks_intro.rst:59
msgid ""
"\"plays\" are more or less a sports analogy.  You can have quite a lot of"
" plays that affect your systems to do different things.  It's not as if "
"you were just defining one particular state or model, and you can run "
"different plays at different times."
msgstr ""
"\"plays\"\\ 라는 이름은 스포츠 경기처럼 여러번 반복하여 다른 일을 할 수 있다는 비유이다. 어떤 하나의 특정한 상태나 "
"모형을 만드는 게 아니고 여러번 반복해서 플레이할 수 있다는 뜻이다. "

#: ../../rst/user_guide/playbooks_intro.rst:65
#, fuzzy
msgid ""
"For starters, here's a playbook, ``verify-apache.yml`` that contains just"
" one play::"
msgstr "처음 시작하는 사용자를 위해 하나의 플레이만 있는 플레이북의 예를 보인다::"

#: ../../rst/user_guide/playbooks_intro.rst:94
msgid ""
"Playbooks can contain multiple plays. You may have a playbook that "
"targets first the web servers, and then the database servers. For "
"example::"
msgstr ""
"플레이북은 여러개의 플레이를 담을 수도 있다. 다음처럼 우선 웹 서버를 목표로 하고 그 다음에 데이터베이스 서버를 목표를 하는 "
"플레이북도 있을 수 있다.:: "

#: ../../rst/user_guide/playbooks_intro.rst:124
msgid ""
"You can use this method to switch between the host group you're "
"targeting, the username logging into the remote servers, whether to sudo "
"or not, and so forth. Plays, like tasks, run in the order specified in "
"the playbook: top to bottom."
msgstr ""
"이런 방법으로 여러개의 호스트 그룹 사이를 왔다갔다할 수 있다. 원격서버에 sudo로 접근할 수도 있고 특정 사용자로 로그인할 수도"
" 있다. 플레이는 작업처럼 플레이북에서 위에서 아래로 순차적으로 실행된다."

#: ../../rst/user_guide/playbooks_intro.rst:129
msgid ""
"Below, we'll break down what the various features of the playbook "
"language are."
msgstr "이제 플레북 언어의 여러가지 특징을 설명한다."

#: ../../rst/user_guide/playbooks_intro.rst:134
msgid "Basics"
msgstr "기초"

#: ../../rst/user_guide/playbooks_intro.rst:139
msgid "Hosts and Users"
msgstr "호스트와 사용자"

#: ../../rst/user_guide/playbooks_intro.rst:141
msgid ""
"For each play in a playbook, you get to choose which machines in your "
"infrastructure to target and what remote user to complete the steps "
"(called tasks) as."
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:144
msgid ""
"The ``hosts`` line is a list of one or more groups or host patterns, "
"separated by colons, as described in the :ref:`intro_patterns` "
"documentation.  The ``remote_user`` is just the name of the user "
"account::"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:154
msgid ""
"The ``remote_user`` parameter was formerly called just ``user``. It was "
"renamed in Ansible 1.4 to make it more distinguishable from the **user** "
"module (used to create users on remote systems)."
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:156
msgid "Remote users can also be defined per task::"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:166
msgid ""
"Support for running things as another user is also available (see "
":ref:`become`)::"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:173
msgid ""
"You can also use keyword ``become`` on a particular task instead of the "
"whole play::"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:186
msgid "You can also login as you, and then become a user different than root::"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:194
msgid "You can also use other privilege escalation methods, like su::"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:202
msgid ""
"If you need to specify a password for sudo, run ``ansible-playbook`` with"
" ``--ask-become-pass`` or ``-K``. If you run a playbook utilizing "
"``become`` and the playbook seems to hang, it's probably stuck at the "
"privilege escalation prompt and can be stopped using `Control-C`, "
"allowing you to re-execute the playbook adding the appropriate password."
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:209
msgid ""
"When using ``become_user`` to a user other than root, the module "
"arguments are briefly written into a random tempfile in ``/tmp``. These "
"are deleted immediately after the command is executed.  This only occurs "
"when changing privileges from a user like 'bob' to 'timmy', not when "
"going from 'bob' to 'root', or logging in directly as 'bob' or 'root'.  "
"If it concerns you that this data is briefly readable (not writable), "
"avoid transferring unencrypted passwords with `become_user` set.  In "
"other cases, ``/tmp`` is not used and this does not come into play. "
"Ansible also takes care to not log password parameters."
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:225
msgid ""
"You can also control the order in which hosts are run. The default is to "
"follow the order supplied by the inventory::"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:234
msgid "Possible values for order are:"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:236
msgid "inventory:"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:237
msgid "The default. The order is 'as provided' by the inventory"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:238
msgid "reverse_inventory:"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:239
msgid ""
"As the name implies, this reverses the order 'as provided' by the "
"inventory"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:240
msgid "sorted:"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:241
msgid "Hosts are alphabetically sorted by name"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:242
msgid "reverse_sorted:"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:243
msgid "Hosts are sorted by name in reverse alphabetical order"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:246
msgid "shuffle:"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:245
msgid "Hosts are randomly ordered each run"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:251
msgid "Tasks list"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:253
msgid ""
"Each play contains a list of tasks.  Tasks are executed in order, one at "
"a time, against all machines matched by the host pattern, before moving "
"on to the next task.  It is important to understand that, within a play, "
"all hosts are going to get the same task directives.  It is the purpose "
"of a play to map a selection of hosts to tasks."
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:259
msgid ""
"When running the playbook, which runs top to bottom, hosts with failed "
"tasks are taken out of the rotation for the entire playbook.  If things "
"fail, simply correct the playbook file and rerun."
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:262
msgid ""
"The goal of each task is to execute a module, with very specific "
"arguments. Variables can be used in arguments to modules."
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:265
msgid ""
"Modules should be idempotent, that is, running a module multiple times in"
" a sequence should have the same effect as running it just once. One way "
"to achieve idempotency is to have a module check whether its desired "
"final state has already been achieved, and if that state has been "
"achieved, to exit without performing any actions. If all the modules a "
"playbook uses are idempotent, then the playbook itself is likely to be "
"idempotent, so re-running the playbook should be safe."
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:273
msgid ""
"The **command** and **shell** modules will typically rerun the same "
"command again, which is totally ok if the command is something like "
"``chmod`` or ``setsebool``, etc.  Though there is a ``creates`` flag "
"available which can be used to make these modules also idempotent."
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:278
msgid ""
"Every task should have a ``name``, which is included in the output from "
"running the playbook.   This is human readable output, and so it is "
"useful to provide good descriptions of each task step.  If the name is "
"not provided though, the string fed to 'action' will be used for output."
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:284
msgid ""
"Tasks can be declared using the legacy ``action: module options`` format,"
" but it is recommended that you use the more conventional ``module: "
"options`` format. This recommended format is used throughout the "
"documentation, but you may encounter the older format in some playbooks."
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:289
msgid ""
"Here is what a basic task looks like. As with most modules, the service "
"module takes ``key=value`` arguments::"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:298
msgid ""
"The **command** and **shell** modules are the only modules that just take"
" a list of arguments and don't use the ``key=value`` form.  This makes "
"them work as simply as you would expect::"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:306
msgid ""
"The **command** and **shell** module care about return codes, so if you "
"have a command whose successful exit code is not zero, you may wish to do"
" this::"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:313
msgid "Or this::"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:321
msgid ""
"If the action line is getting too long for comfort you can break it on a "
"space and indent any continuation lines::"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:329
msgid ""
"Variables can be used in action lines.   Suppose you defined a variable "
"called ``vhost`` in the ``vars`` section, you could do this::"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:338
msgid "Those same variables are usable in templates, which we'll get to later."
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:340
msgid ""
"Now in a very basic playbook all the tasks will be listed directly in "
"that play, though it will usually make more sense to break up tasks as "
"described in :ref:`playbooks_reuse`."
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:346
msgid "Action Shorthand"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:350
msgid "Ansible prefers listing modules like this::"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:356
msgid "Early versions of Ansible used the following format, which still works::"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:364
msgid "Handlers: Running Operations On Change"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:366
msgid ""
"As we've mentioned, modules should be idempotent and can relay when they "
"have made a change on the remote system.   Playbooks recognize this and "
"have a basic event system that can be used to respond to change."
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:370
msgid ""
"These 'notify' actions are triggered at the end of each block of tasks in"
" a play, and will only be triggered once even if notified by multiple "
"different tasks."
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:373
msgid ""
"For instance, multiple resources may indicate that apache needs to be "
"restarted because they have changed a config file, but apache will only "
"be bounced once to avoid unnecessary restarts."
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:377
msgid ""
"Here's an example of restarting two services when the contents of a file "
"change, but only if the file changes::"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:388
msgid "The things listed in the ``notify`` section of a task are called handlers."
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:391
msgid ""
"Handlers are lists of tasks, not really any different from regular tasks,"
" that are referenced by a globally unique name, and are notified by "
"notifiers.  If nothing notifies a handler, it will not run.  Regardless "
"of how many tasks notify a handler, it will run only once, after all of "
"the tasks complete in a particular play."
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:397
msgid "Here's an example handlers section::"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:409
msgid ""
"You may want your Ansible handlers to use variables. For example, if the "
"name of a service varies slightly by distribution, you want your output "
"to show the exact name of the restarted service for each target machine. "
"Avoid placing variables in the name of the handler. Since handler names "
"are templated early on, Ansible may not have a value available for a "
"handler name like this::"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:415
msgid ""
"If the variable used in the handler name is not available, the entire "
"play fails. Changing that variable mid-play **will not** result in newly "
"created handler."
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:417
msgid ""
"Instead, place variables in the task parameters of your handler. You can "
"load the values using ``include_vars`` like this:"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:432
msgid ""
"As of Ansible 2.2, handlers can also \"listen\" to generic topics, and "
"tasks can notify those topics as follows::"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:451
msgid ""
"This use makes it much easier to trigger multiple handlers. It also "
"decouples handlers from their names, making it easier to share handlers "
"among playbooks and roles (especially when using 3rd party roles from a "
"shared source like Galaxy)."
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:456
msgid ""
"Notify handlers are always run in the same order they are defined, `not` "
"in the order listed in the notify-statement. This is also the case for "
"handlers using `listen`."
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:457
msgid "Handler names and `listen` topics live in a global namespace."
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:458
msgid "Handler names are templatable and `listen` topics are not."
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:459
msgid ""
"Use unique handler names. If you trigger more than one handler with the "
"same name, the first one(s) get overwritten. Only the last one defined "
"will run."
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:460
msgid ""
"You cannot notify a handler that is defined inside of an include. As of "
"Ansible 2.1, this does work, however the include must be `static`."
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:462
msgid "Roles are described later on, but it's worthwhile to point out that:"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:464
msgid ""
"handlers notified within ``pre_tasks``, ``tasks``, and ``post_tasks`` "
"sections are automatically flushed in the end of section where they were "
"notified,"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:465
msgid ""
"handlers notified within ``roles`` section are automatically flushed in "
"the end of ``tasks`` section, but before any ``tasks`` handlers,"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:466
msgid ""
"handlers are play scoped and as such can be used outside of the role they"
" are defined in."
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:468
msgid ""
"If you ever want to flush all the handler commands immediately you can do"
" this::"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:475
msgid ""
"In the above example any queued up handlers would be processed early when"
" the ``meta`` statement was reached.  This is a bit of a niche case but "
"can come in handy from time to time."
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:482
msgid "Executing A Playbook"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:484
msgid ""
"Now that you've learned playbook syntax, how do you run a playbook?  It's"
" simple. Let's run a playbook using a parallelism level of 10::"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:492
msgid "Ansible-Pull"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:494
msgid ""
"Should you want to invert the architecture of Ansible, so that nodes "
"check in to a central location, instead of pushing configuration out to "
"them, you can."
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:497
msgid ""
"The ``ansible-pull`` is a small script that will checkout a repo of "
"configuration instructions from git, and then run ``ansible-playbook`` "
"against that content."
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:500
msgid ""
"Assuming you load balance your checkout location, ``ansible-pull`` scales"
" essentially infinitely."
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:502
msgid "Run ``ansible-pull --help`` for details."
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:504
msgid ""
"There's also a `clever playbook <https://github.com/ansible/ansible-"
"examples/blob/master/language_features/ansible_pull.yml>`_ available to "
"configure ``ansible-pull`` via a crontab from push mode."
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:509
#, fuzzy
msgid "Linting playbooks"
msgstr "플레이북 소개"

#: ../../rst/user_guide/playbooks_intro.rst:511
msgid ""
"You can use `ansible-lint <https://docs.ansible.com/ansible-"
"lint/index.html>`_ to run a detail check of your playbooks before you "
"execute them."
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:513
msgid ""
"For example, if you run ``ansible-lint`` on the :ref:`verify-apache.yml "
"playbook <apache-playbook>` introduced earlier in this section, you'll "
"get the following results:"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:522
msgid ""
"The `ansible-lint default rules <https://docs.ansible.com/ansible-"
"lint/rules/default_rules.html>`_ page describes each error. For "
"``[403]``, the recommended fix is to change ``state: latest`` to ``state:"
" present`` in the playbook."
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:526
msgid "Other playbook verification options"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:527
msgid ""
"See :ref:`validate-playbook-tools` for a detailed list of tools you can "
"use to verify your playbooks. Here are some others that you should "
"consider:"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:529
msgid ""
"To check the syntax of a playbook, use ``ansible-playbook`` with the "
"``--syntax-check`` flag. This will run the playbook file through the "
"parser to ensure its included files, roles, etc. have no syntax problems."
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:532
msgid ""
"Look at the bottom of the playbook execution for a summary of the nodes "
"that were targeted and how they performed. General failures and fatal "
"\"unreachable\" communication attempts are kept separate in the counts."
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:535
msgid ""
"If you ever want to see detailed output from successful modules as well "
"as unsuccessful ones, use the ``--verbose`` flag.  This is available in "
"Ansible 0.5 and later."
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:538
msgid ""
"To see what hosts would be affected by a playbook before you run it, you "
"can do this::"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:545
msgid "`ansible-lint <https://docs.ansible.com/ansible-lint/index.html>`_"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:546
msgid "Learn how to test Ansible Playbooks syntax"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:547
msgid ":ref:`yaml_syntax`"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:548
msgid "Learn about YAML syntax"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:549
msgid ":ref:`playbooks_best_practices`"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:550
msgid "Various tips about managing playbooks in the real world"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:551
msgid ":ref:`all_modules`"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:552
msgid "Learn about available modules"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:553
msgid ":ref:`developing_modules`"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:554
msgid "Learn how to extend Ansible by writing your own modules"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:555
msgid ":ref:`intro_patterns`"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:556
msgid "Learn about how to select hosts"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:557
msgid "`GitHub examples directory <https://github.com/ansible/ansible-examples>`_"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:558
msgid "Complete end-to-end playbook examples"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:559
msgid "`Mailing List <https://groups.google.com/group/ansible-project>`_"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:560
msgid "Questions? Help? Ideas?  Stop by the list on Google Groups"
msgstr ""

#~ msgid ""
#~ "The ``hosts`` line is a list of"
#~ " one or more groups or host "
#~ "patterns, separated by colons, as "
#~ "described in the :doc:`intro_patterns` "
#~ "documentation.  The ``remote_user`` is just"
#~ " the name of the user account::"
#~ msgstr ""

#~ msgid ""
#~ "Support for running things as another"
#~ " user is also available (see "
#~ ":doc:`become`)::"
#~ msgstr ""

#~ msgid ""
#~ "If you need to specify a password"
#~ " to sudo, run ``ansible-playbook`` "
#~ "with ``--ask-become-pass`` or when "
#~ "using the old sudo syntax ``--ask-"
#~ "sudo-pass`` (``-K``).  If you run a"
#~ " become playbook and the playbook "
#~ "seems to hang, it's probably stuck "
#~ "at the privilege escalation prompt. Just"
#~ " `Control-C` to kill it and run "
#~ "it again adding the appropriate "
#~ "password."
#~ msgstr ""

#~ msgid ""
#~ "The goal of each task is to "
#~ "execute a module, with very specific "
#~ "arguments. Variables, as mentioned above, "
#~ "can be used in arguments to "
#~ "modules."
#~ msgstr ""

#~ msgid ""
#~ "Now in a very basic playbook all"
#~ " the tasks will be listed directly"
#~ " in that play, though it will "
#~ "usually make more sense to break "
#~ "up tasks as described in "
#~ ":doc:`playbooks_reuse`."
#~ msgstr ""

#~ msgid "Tips and Tricks"
#~ msgstr ""

#~ msgid ""
#~ "Look at the bottom of the playbook"
#~ " execution for a summary of the "
#~ "nodes that were targeted and how "
#~ "they performed.   General failures and "
#~ "fatal \"unreachable\" communication attempts "
#~ "are kept separate in the counts."
#~ msgstr ""

