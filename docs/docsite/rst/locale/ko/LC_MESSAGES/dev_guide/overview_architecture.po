# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2013-2018 Ansible, Inc
# This file is distributed under the same license as the Ansible
# Documentation package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Ansible Documentation 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-08-30 11:08+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../rst/dev_guide/overview_architecture.rst:3
msgid "Ansible architecture"
msgstr ""

#: ../../rst/dev_guide/overview_architecture.rst:5
msgid ""
"Ansible is a radically simple IT automation engine that automates cloud "
"provisioning, configuration management, application deployment, intra-"
"service orchestration, and many other IT needs."
msgstr ""

#: ../../rst/dev_guide/overview_architecture.rst:7
msgid ""
"Being designed for multi-tier deployments since day one, Ansible models "
"your IT infrastructure by describing how all of your systems inter-"
"relate, rather than just managing one system at a time."
msgstr ""

#: ../../rst/dev_guide/overview_architecture.rst:9
msgid ""
"It uses no agents and no additional custom security infrastructure, so "
"it's easy to deploy - and most importantly, it uses a very simple "
"language (YAML, in the form of Ansible Playbooks) that allow you to "
"describe your automation jobs in a way that approaches plain English."
msgstr ""

#: ../../rst/dev_guide/overview_architecture.rst:11
msgid ""
"In this section, we'll give you a really quick overview of how Ansible "
"works so you can see how the pieces fit together."
msgstr ""

#: ../../rst/dev_guide/overview_architecture.rst:17
msgid "Modules"
msgstr ""

#: ../../rst/dev_guide/overview_architecture.rst:19
msgid ""
"Ansible works by connecting to your nodes and pushing out scripts called "
"\"Ansible modules\" to them. Most modules accept parameters that describe"
" the desired state of the system. Ansible then executes these modules "
"(over SSH by default), and removes them when finished. Your library of "
"modules can reside on any machine, and there are no servers, daemons, or "
"databases required."
msgstr ""

#: ../../rst/dev_guide/overview_architecture.rst:22
msgid ""
"You can :ref:`write your own modules <developing_modules_general>`, "
"though you should first consider :ref:`whether you should "
"<developing_modules>`. Typically you'll work with your favorite terminal "
"program, a text editor, and probably a version control system to keep "
"track of changes to your content. You may write specialized modules in "
"any language that can return JSON (Ruby, Python, bash, etc)."
msgstr ""

#: ../../rst/dev_guide/overview_architecture.rst:25
msgid "Module utilities"
msgstr ""

#: ../../rst/dev_guide/overview_architecture.rst:27
msgid ""
"When multiple modules use the same code, Ansible stores those functions "
"as module utilities to minimize duplication and maintenance. For example,"
" the code that parses URLs is ``lib/ansible/module_utils/url.py``. You "
"can :ref:`write your own module utilities <developing_module_utilities>` "
"as well. Module utilities may only be written in Python or in PowerShell."
msgstr ""

#: ../../rst/dev_guide/overview_architecture.rst:30
msgid "Plugins"
msgstr ""

#: ../../rst/dev_guide/overview_architecture.rst:32
msgid ""
":ref:`Plugins <plugins_lookup>` augment Ansible's core functionality. "
"While modules execute on the target system in separate processes (usually"
" that means on a remote system), plugins execute on the control node "
"within the ``/usr/bin/ansible`` process. Plugins offer options and "
"extensions for the core features of Ansible - transforming data, logging "
"output, connecting to inventory, and more. Ansible ships with a number of"
" handy plugins, and you can easily :ref:`write your own "
"<developing_plugins>`. For example, you can write an :ref:`inventory "
"plugin <developing_inventory>` to connect to any datasource that returns "
"JSON. Plugins must be written in Python."
msgstr ""

#: ../../rst/dev_guide/overview_architecture.rst:35
msgid "Inventory"
msgstr ""

#: ../../rst/dev_guide/overview_architecture.rst:37
msgid ""
"By default, Ansible represents the machines it manages in a file (INI, "
"YAML, etc.) that puts all of your managed machines in groups of your own "
"choosing."
msgstr ""

#: ../../rst/dev_guide/overview_architecture.rst:39
msgid ""
"To add new machines, there is no additional SSL signing server involved, "
"so there's never any hassle deciding why a particular machine didn't get "
"linked up due to obscure NTP or DNS issues."
msgstr ""

#: ../../rst/dev_guide/overview_architecture.rst:41
msgid ""
"If there's another source of truth in your infrastructure, Ansible can "
"also connect to that. Ansible can draw inventory, group, and variable "
"information from sources like EC2, Rackspace, OpenStack, and more."
msgstr ""

#: ../../rst/dev_guide/overview_architecture.rst:43
msgid "Here's what a plain text inventory file looks like::"
msgstr ""

#: ../../rst/dev_guide/overview_architecture.rst:54
msgid ""
"Once inventory hosts are listed, variables can be assigned to them in "
"simple text files (in a subdirectory called 'group_vars/' or 'host_vars/'"
" or directly in the inventory file."
msgstr ""

#: ../../rst/dev_guide/overview_architecture.rst:56
msgid ""
"Or, as already mentioned, use a dynamic inventory to pull your inventory "
"from data sources like EC2, Rackspace, or OpenStack."
msgstr ""

#: ../../rst/dev_guide/overview_architecture.rst:59
msgid "Playbooks"
msgstr ""

#: ../../rst/dev_guide/overview_architecture.rst:61
msgid ""
"Playbooks can finely orchestrate multiple slices of your infrastructure "
"topology, with very detailed control over how many machines to tackle at "
"a time.  This is where Ansible starts to get most interesting."
msgstr ""

#: ../../rst/dev_guide/overview_architecture.rst:63
msgid ""
"Ansible's approach to orchestration is one of finely-tuned simplicity, as"
" we believe your automation code should make perfect sense to you years "
"down the road and there should be very little to remember about special "
"syntax or features."
msgstr ""

#: ../../rst/dev_guide/overview_architecture.rst:65
msgid "Here's what a simple playbook looks like::"
msgstr ""

#: ../../rst/dev_guide/overview_architecture.rst:82
msgid "The Ansible search path"
msgstr ""

#: ../../rst/dev_guide/overview_architecture.rst:84
msgid ""
"Modules, module utilities, plugins, playbooks, and roles can live in "
"multiple locations. If you write your own code to extend Ansible's core "
"features, you may have multiple files with similar or the same names in "
"different locations on your Ansible control node. The search path "
"determines which of these files Ansible will discover and use on any "
"given playbook run."
msgstr ""

#: ../../rst/dev_guide/overview_architecture.rst:87
msgid ""
"Ansible's search path grows incrementally over a run. As Ansible finds "
"each playbook and role included in a given run, it appends any "
"directories related to that playbook or role to the search path. Those "
"directories remain in scope for the duration of the run, even after the "
"playbook or role has finished executing. Ansible loads modules, module "
"utilities, and plugins in this order:"
msgstr ""

#: ../../rst/dev_guide/overview_architecture.rst:93
msgid ""
"Directories adjacent to a playbook specified on the command line. If you "
"run Ansible with ``ansible-playbook /path/to/play.yml``, Ansible appends "
"these directories if they exist:"
msgstr ""

#: ../../rst/dev_guide/overview_architecture.rst:101
msgid ""
"Directories adjacent to a playbook that is statically imported by a "
"playbook specified on the command line. If ``play.yml`` includes ``- "
"import_playbook: /path/to/subdir/play1.yml``, Ansible appends these "
"directories if they exist:"
msgstr ""

#: ../../rst/dev_guide/overview_architecture.rst:111
msgid ""
"Subdirectories of a role directory referenced by a playbook. If "
"``play.yml`` runs ``myrole``, Ansible appends these directories if they "
"exist:"
msgstr ""

#: ../../rst/dev_guide/overview_architecture.rst:120
msgid ""
"Directories specified as default paths in ``ansible.cfg`` or by the "
"related environment variables, including the paths for the various plugin"
" types. See :ref:`ansible_configuration_settings` for more information. "
"Sample ``ansible.cfg`` fields:"
msgstr ""

#: ../../rst/dev_guide/overview_architecture.rst:131
msgid "Sample environment variables:"
msgstr ""

#: ../../rst/dev_guide/overview_architecture.rst:140
msgid "The standard directories that ship as part of the Ansible distribution."
msgstr ""

#: ../../rst/dev_guide/overview_architecture.rst:144
msgid ""
"Modules, module utilities, and plugins in user-specified directories will"
" override the standard versions. This includes some files with generic "
"names. For example, if you have a file named ``basic.py`` in a user-"
"specified directory, it will override the standard "
"``ansible.module_utils.basic``."
msgstr ""

#: ../../rst/dev_guide/overview_architecture.rst:149
msgid ""
"If you have more than one module, module utility, or plugin with the same"
" name in different user-specified directories, the order of commands at "
"the command line and the order of includes and roles in each play will "
"affect which one is found and used on that particular play."
msgstr ""

#~ msgid "Ansible Architecture"
#~ msgstr ""

#~ msgid ""
#~ "Ansible works by connecting to your "
#~ "nodes and pushing out small programs,"
#~ " called \"Ansible Modules\" to them. "
#~ "These programs are written to be "
#~ "resource models of the desired state "
#~ "of the system. Ansible then executes "
#~ "these modules (over SSH by default), "
#~ "and removes them when finished."
#~ msgstr ""

#~ msgid ""
#~ "Your library of modules can reside "
#~ "on any machine, and there are no"
#~ " servers, daemons, or databases required."
#~ " Typically you'll work with your "
#~ "favorite terminal program, a text "
#~ "editor, and probably a version control"
#~ " system to keep track of changes "
#~ "to your content."
#~ msgstr ""

#~ msgid ""
#~ "Plugins are pieces of code that "
#~ "augment Ansible's core functionality. Ansible"
#~ " ships with a number of handy "
#~ "plugins, and you can easily write "
#~ "your own."
#~ msgstr ""

#~ msgid ""
#~ "By default, Ansible represents what "
#~ "machines it manages using a very "
#~ "simple INI file that puts all of"
#~ " your managed machines in groups of"
#~ " your own choosing."
#~ msgstr ""

#~ msgid ""
#~ "If there's another source of truth "
#~ "in your infrastructure, Ansible can also"
#~ " plugin to that, such as drawing "
#~ "inventory, group, and variable information "
#~ "from sources like EC2, Rackspace, "
#~ "OpenStack, and more."
#~ msgstr ""

#~ msgid "Extending Ansible with plug-ins and the API"
#~ msgstr ""

#~ msgid ""
#~ "Should you want to write your own,"
#~ " Ansible modules can be written in"
#~ " any language that can return JSON"
#~ " (Ruby, Python, bash, etc). Inventory "
#~ "can also plug in to any datasource"
#~ " by writing a program that speaks "
#~ "to that datasource and returns JSON. "
#~ "There's also various Python APIs for "
#~ "extending Ansible's connection types (SSH "
#~ "is not the only transport possible), "
#~ "callbacks (how Ansible logs, etc), and"
#~ " even for adding new server side "
#~ "behaviors."
#~ msgstr ""

