# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2013-2018 Ansible, Inc
# This file is distributed under the same license as the Ansible
# Documentation package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Ansible Documentation 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-10-07 12:18+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.7.0\n"

#: ../../rst/dev_guide/developing_program_flow_modules.rst:6
msgid "Ansible module architecture"
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:8
msgid ""
"If you're working on Ansible's Core code, writing an Ansible module, or "
"developing an action plugin, this deep dive helps you understand how "
"Ansible's program flow executes. If you're just using Ansible Modules in "
"playbooks, you can skip this section."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:16
msgid "Types of modules"
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:18
msgid ""
"Ansible supports several different types of modules in its code base. "
"Some of these are for backwards compatibility and others are to enable "
"flexibility."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:24
msgid "Action plugins"
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:26
msgid ""
"Action plugins look like modules to anyone writing a playbook. Usage "
"documentation for most action plugins lives inside a module of the same "
"name. Some action plugins do all the work, with the module providing only"
" documentation. Some action plugins execute modules. The ``normal`` "
"action plugin executes modules that don't have special action plugins. "
"Action plugins always execute on the controller."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:28
msgid ""
"Some action plugins do all their work on the controller. For example, the"
" :ref:`debug <debug_module>` action plugin (which prints text for the "
"user to see) and the :ref:`assert <assert_module>` action plugin (which "
"tests whether values in a playbook satisfy certain criteria) execute "
"entirely on the controller."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:33
msgid ""
"Most action plugins set up some values on the controller, then invoke an "
"actual module on the managed node that does something with these values. "
"For example, the :ref:`template <template_module>` action plugin takes "
"values from the user to construct a file in a temporary location on the "
"controller using variables from the playbook environment. It then "
"transfers the temporary file to a temporary file on the remote system. "
"After that, it invokes the :ref:`copy module <copy_module>` which "
"operates on the remote system to move the file into its final location, "
"sets file permissions, and so on."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:44
msgid "New-style modules"
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:46
msgid ""
"All of the modules that ship with Ansible fall into this category. While "
"you can write modules in any language, all official modules (shipped with"
" Ansible) use either Python or PowerShell."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:48
msgid ""
"New-style modules have the arguments to the module embedded inside of "
"them in some manner. Old-style modules must copy a separate file over to "
"the managed node, which is less efficient as it requires two over-the-"
"wire connections instead of only one."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:56
msgid "Python"
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:58
msgid ""
"New-style Python modules use the :ref:`Ansiballz` framework for "
"constructing modules. These modules use imports from "
":code:`ansible.module_utils` to pull in boilerplate module code, such as "
"argument parsing, formatting of return values as :term:`JSON`, and "
"various file operations."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:63
msgid ""
"In Ansible, up to version 2.0.x, the official Python modules used the "
":ref:`module_replacer` framework.  For module authors, :ref:`Ansiballz` "
"is largely a superset of :ref:`module_replacer` functionality, so you "
"usually do not need to know about one versus the other."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:71
msgid "PowerShell"
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:73
msgid ""
"New-style PowerShell modules use the :ref:`module_replacer` framework for"
" constructing modules. These modules get a library of PowerShell code "
"embedded in them before being sent to the managed node."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:80
msgid "JSONARGS modules"
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:82
msgid ""
"These modules are scripts that include the string "
"``<<INCLUDE_ANSIBLE_MODULE_JSON_ARGS>>`` in their body. This string is "
"replaced with the JSON-formatted argument string. These modules typically"
" set a variable to that value like this:"
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:90
msgid "Which is expanded as:"
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:96
msgid ""
"Ansible outputs a :term:`JSON` string with bare quotes. Double quotes are"
" used to quote string values, double quotes inside of string values are "
"backslash escaped, and single quotes may appear unescaped inside of a "
"string value. To use JSONARGS, your scripting language must have a way to"
" handle this type of string. The example uses Python's triple quoted "
"strings to do this. Other scripting languages may have a similar quote "
"character that won't be confused by any quotes in the JSON or it may "
"allow you to define your own start-of-quote and end-of-quote characters. "
"If the language doesn't give you any of these then you'll need to write a"
" :ref:`non-native JSON module <flow_want_json_modules>` or :ref:`Old-"
"style module <flow_old_style_modules>` instead."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:108
msgid ""
"These modules typically parse the contents of ``json_arguments`` using a "
"JSON library and then use them as native variables throughout the code."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:114
msgid "Non-native want JSON modules"
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:116
msgid ""
"If a module has the string ``WANT_JSON`` in it anywhere, Ansible treats "
"it as a non-native module that accepts a filename as its only command "
"line parameter. The filename is for a temporary file containing a "
":term:`JSON` string containing the module's parameters. The module needs "
"to open the file, read and parse the parameters, operate on the data, and"
" print its return data as a JSON encoded dictionary to stdout before "
"exiting."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:123
msgid ""
"These types of modules are self-contained entities. As of Ansible 2.1, "
"Ansible only modifies them to change a shebang line if present."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:126
msgid ""
"Examples of Non-native modules written in ruby are in the `Ansible for "
"Rubyists <https://github.com/ansible/ansible-for-rubyists>`_ repository."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:132
msgid "Binary modules"
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:134
msgid ""
"From Ansible 2.2 onwards, modules may also be small binary programs. "
"Ansible doesn't perform any magic to make these portable to different "
"systems so they may be specific to the system on which they were compiled"
" or require other binary runtime dependencies. Despite these drawbacks, "
"you may have to compile a custom module against a specific binary library"
" if that's the only way to get access to certain resources."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:141
msgid ""
"Binary modules take their arguments and return data to Ansible in the "
"same way as :ref:`want JSON modules <flow_want_json_modules>`."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:144
msgid ""
"One example of a `binary module "
"<https://github.com/ansible/ansible/blob/devel/test/integration/targets/binary_modules/library/helloworld.go>`_"
" written in go."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:151
msgid "Old-style modules"
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:153
msgid ""
"Old-style modules are similar to :ref:`want JSON modules "
"<flow_want_json_modules>`, except that the file that they take contains "
"``key=value`` pairs for their parameters instead of :term:`JSON`. Ansible"
" decides that a module is old-style when it doesn't have any of the "
"markers that would show that it is one of the other types."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:162
msgid "How modules are executed"
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:164
msgid ""
"When a user uses :program:`ansible` or :program:`ansible-playbook`, they "
"specify a task to execute. The task is usually the name of a module along"
" with several parameters to be passed to the module. Ansible takes these "
"values and processes them in various ways before they are finally "
"executed on the remote machine."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:173
msgid "Executor/task_executor"
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:175
msgid ""
"The TaskExecutor receives the module name and parameters that were parsed"
" from the :term:`playbook <playbooks>` (or from the command line in the "
"case of :command:`/usr/bin/ansible`). It uses the name to decide whether "
"it's looking at a module or an :ref:`Action Plugin "
"<flow_action_plugins>`. If it's a module, it loads the :ref:`Normal "
"Action Plugin <flow_normal_action_plugin>` and passes the name, "
"variables, and other information about the task and play to that Action "
"Plugin for further processing."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:186
msgid "The ``normal`` action plugin"
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:188
msgid ""
"The ``normal`` action plugin executes the module on the remote host. It "
"is the primary coordinator of much of the work to actually execute the "
"module on the managed machine."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:192
msgid ""
"It loads the appropriate connection plugin for the task, which then "
"transfers or executes as needed to create a connection to that host."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:194
msgid ""
"It adds any internal Ansible properties to the module's parameters (for "
"instance, the ones that pass along ``no_log`` to the module)."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:196
msgid ""
"It works with other plugins (connection, shell, become, other action "
"plugins) to create any temporary files on the remote machine and cleans "
"up afterwards."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:199
msgid ""
"It pushes the module and module parameters to the remote host, although "
"the :ref:`module_common <flow_executor_module_common>` code described in "
"the next section decides which format those will take."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:203
msgid ""
"It handles any special cases regarding modules (for instance, async "
"execution, or complications around Windows modules that must have the "
"same names as Python modules, so that internal calling of modules from "
"other Action Plugins work.)"
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:206
msgid ""
"Much of this functionality comes from the `BaseAction` class, which lives"
" in :file:`plugins/action/__init__.py`. It uses the ``Connection`` and "
"``Shell`` objects to do its work."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:211
msgid ""
"When :term:`tasks <tasks>` are run with the ``async:`` parameter, Ansible"
" uses the ``async`` Action Plugin instead of the ``normal`` Action Plugin"
" to invoke it. That program flow is currently not documented. Read the "
"source for information on how that works."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:219
msgid "Executor/module_common.py"
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:221
msgid ""
"Code in :file:`executor/module_common.py` assembles the module to be "
"shipped to the managed node. The module is first read in, then examined "
"to determine its type:"
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:225
msgid ""
":ref:`PowerShell <flow_powershell_modules>` and :ref:`JSON-args modules "
"<flow_jsonargs_modules>` are passed through :ref:`Module Replacer "
"<module_replacer>`."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:226
msgid ""
"New-style :ref:`Python modules <flow_python_modules>` are assembled by "
":ref:`Ansiballz`."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:227
msgid ""
":ref:`Non-native-want-JSON <flow_want_json_modules>`, :ref:`Binary "
"modules <flow_binary_modules>`, and :ref:`Old-Style modules "
"<flow_old_style_modules>` aren't touched by either of these and pass "
"through unchanged."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:229
msgid ""
"After the assembling step, one final modification is made to all modules "
"that have a shebang line. Ansible checks whether the interpreter in the "
"shebang line has a specific path configured via an "
"``ansible_$X_interpreter`` inventory variable. If it does, Ansible "
"substitutes that path for the interpreter path given in the module. After"
" this, Ansible returns the complete module data and the module type to "
"the :ref:`Normal Action <flow_normal_action_plugin>` which continues "
"execution of the module."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:239
msgid "Assembler frameworks"
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:241
msgid ""
"Ansible supports two assembler frameworks: Ansiballz and the older Module"
" Replacer."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:246
msgid "Module Replacer framework"
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:248
msgid ""
"The Module Replacer framework is the original framework implementing new-"
"style modules, and is still used for PowerShell modules. It is "
"essentially a preprocessor (like the C Preprocessor for those familiar "
"with that programming language). It does straight substitutions of "
"specific substring patterns in the module file. There are two types of "
"substitutions:"
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:254
msgid ""
"Replacements that only happen in the module file. These are public "
"replacement strings that modules can utilize to get helpful boilerplate "
"or access to arguments."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:258
msgid ""
":code:`from ansible.module_utils.MOD_LIB_NAME import *` is replaced with "
"the contents of the :file:`ansible/module_utils/MOD_LIB_NAME.py`  These "
"should only be used with :ref:`new-style Python modules "
"<flow_python_modules>`."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:261
msgid ""
":code:`#<<INCLUDE_ANSIBLE_MODULE_COMMON>>` is equivalent to :code:`from "
"ansible.module_utils.basic import *` and should also only apply to new-"
"style Python modules."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:264
msgid ""
":code:`# POWERSHELL_COMMON` substitutes the contents of "
":file:`ansible/module_utils/powershell.ps1`. It should only be used with "
":ref:`new-style Powershell modules <flow_powershell_modules>`."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:268
msgid ""
"Replacements that are used by ``ansible.module_utils`` code. These are "
"internal replacement patterns. They may be used internally, in the above "
"public replacements, but shouldn't be used directly by modules."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:270
msgid ""
":code:`\"<<ANSIBLE_VERSION>>\"` is substituted with the Ansible version."
"  In :ref:`new-style Python modules <flow_python_modules>` under the "
":ref:`Ansiballz` framework the proper way is to instead instantiate an "
"`AnsibleModule` and then access the version from "
":attr:``AnsibleModule.ansible_version``."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:275
msgid ""
":code:`\"<<INCLUDE_ANSIBLE_MODULE_COMPLEX_ARGS>>\"` is substituted with a"
" string which is the Python ``repr`` of the :term:`JSON` encoded module "
"parameters. Using ``repr`` on the JSON string makes it safe to embed in a"
" Python file. In new-style Python modules under the Ansiballz framework "
"this is better accessed by instantiating an `AnsibleModule` and then "
"using :attr:`AnsibleModule.params`."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:281
msgid ""
":code:`<<SELINUX_SPECIAL_FILESYSTEMS>>` substitutes a string which is a "
"comma separated list of file systems which have a file system dependent "
"security context in SELinux. In new-style Python modules, if you really "
"need this you should instantiate an `AnsibleModule` and then use "
":attr:`AnsibleModule._selinux_special_fs`. The variable has also changed "
"from a comma separated string of file system names to an actual python "
"list of filesystem names."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:288
msgid ""
":code:`<<INCLUDE_ANSIBLE_MODULE_JSON_ARGS>>` substitutes the module "
"parameters as a JSON string. Care must be taken to properly quote the "
"string as JSON data may contain quotes. This pattern is not substituted "
"in new-style Python modules as they can get the module parameters another"
" way."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:293
msgid ""
"The string :code:`syslog.LOG_USER` is replaced wherever it occurs with "
"the ``syslog_facility`` which was named in :file:`ansible.cfg` or any "
"``ansible_syslog_facility`` inventory variable that applies to this host."
"  In new-style Python modules this has changed slightly. If you really "
"need to access it, you should instantiate an `AnsibleModule` and then use"
" :attr:`AnsibleModule._syslog_facility` to access it. It is no longer the"
" actual syslog facility and is now the name of the syslog facility. See "
"the :ref:`documentation on internal arguments <flow_internal_arguments>` "
"for details."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:306
msgid "Ansiballz framework"
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:308
msgid ""
"The Ansiballz framework was adopted in Ansible 2.1 and is used for all "
"new-style Python modules. Unlike the Module Replacer, Ansiballz uses real"
" Python imports of things in :file:`ansible/module_utils` instead of "
"merely preprocessing the module. It does this by constructing a zipfile "
"-- which includes the module file, files in :file:`ansible/module_utils` "
"that are imported by the module, and some boilerplate to pass in the "
"module's parameters. The zipfile is then Base64 encoded and wrapped in a "
"small Python script which decodes the Base64 encoding and places the "
"zipfile into a temp directory on the managed node. It then extracts just "
"the Ansible module script from the zip file and places that in the "
"temporary directory as well. Then it sets the PYTHONPATH to find Python "
"modules inside of the zip file and imports the Ansible module as the "
"special name, ``__main__``. Importing it as ``__main__`` causes Python to"
" think that it is executing a script rather than simply importing a "
"module. This lets Ansible run both the wrapper script and the module code"
" in a single copy of Python on the remote machine."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:322
msgid "Ansible wraps the zipfile in the Python script for two reasons:"
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:324
msgid ""
"for compatibility with Python 2.6 which has a less functional version of "
"Python's ``-m`` command line switch."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:327
msgid ""
"so that pipelining will function properly. Pipelining needs to pipe the "
"Python module into the Python interpreter on the remote node. Python "
"understands scripts on stdin but does not understand zip files."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:331
msgid ""
"Prior to Ansible 2.7, the module was executed via a second Python "
"interpreter instead of being executed inside of the same process. This "
"change was made once Python-2.4 support was dropped to speed up module "
"execution."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:335
msgid ""
"In Ansiballz, any imports of Python modules from the "
":py:mod:`ansible.module_utils` package trigger inclusion of that Python "
"file into the zipfile. Instances of "
":code:`#<<INCLUDE_ANSIBLE_MODULE_COMMON>>` in the module are turned into "
":code:`from ansible.module_utils.basic import *` and :file:`ansible"
"/module-utils/basic.py` is then included in the zipfile. Files that are "
"included from :file:`module_utils` are themselves scanned for imports of "
"other Python modules from :file:`module_utils` to be included in the "
"zipfile as well."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:345
msgid ""
"At present, the Ansiballz Framework cannot determine whether an import "
"should be included if it is a relative import. Always use an absolute "
"import that has :py:mod:`ansible.module_utils` in it to allow Ansiballz "
"to determine that the file should be included."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:354
msgid "Passing args"
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:356
msgid "Arguments are passed differently by the two frameworks:"
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:358
msgid ""
"In :ref:`module_replacer`, module arguments are turned into a JSON-ified "
"string and substituted into the combined module file."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:359
msgid ""
"In :ref:`Ansiballz`, the JSON-ified string is part of the script which "
"wraps the zipfile. Just before the wrapper script imports the Ansible "
"module as ``__main__``, it monkey-patches the private, ``_ANSIBLE_ARGS`` "
"variable in ``basic.py`` with the variable values. When a "
":class:`ansible.module_utils.basic.AnsibleModule` is instantiated, it "
"parses this string and places the args into :attr:`AnsibleModule.params` "
"where it can be accessed by the module's other code."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:362
msgid ""
"If you are writing modules, remember that the way we pass arguments is an"
" internal implementation detail: it has changed in the past and will "
"change again as soon as changes to the common module_utils code allow "
"Ansible modules to forgo using "
":class:`ansible.module_utils.basic.AnsibleModule`. Do not rely on the "
"internal global ``_ANSIBLE_ARGS`` variable."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:365
msgid ""
"Very dynamic custom modules which need to parse arguments before they "
"instantiate an ``AnsibleModule`` may use ``_load_params`` to retrieve "
"those parameters. Although ``_load_params`` may change in breaking ways "
"if necessary to support changes in the code, it is likely to be more "
"stable than either the way we pass parameters or the internal global "
"variable."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:371
msgid ""
"Prior to Ansible 2.7, the Ansible module was invoked in a second Python "
"interpreter and the arguments were then passed to the script over the "
"script's stdin."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:378
msgid "Internal arguments"
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:380
msgid ""
"Both :ref:`module_replacer` and :ref:`Ansiballz` send additional "
"arguments to the module beyond those which the user specified in the "
"playbook. These additional arguments are internal parameters that help "
"implement global Ansible features. Modules often do not need to know "
"about these explicitly as the features are implemented in "
":py:mod:`ansible.module_utils.basic` but certain features need support "
"from the module so it's good to know about them."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:387
msgid ""
"The internal arguments listed here are global. If you need to add a local"
" internal argument to a custom module, create an action plugin for that "
"specific module - see ``_original_basename`` in the `copy action plugin "
"<https://github.com/ansible/ansible/blob/devel/lib/ansible/plugins/action/copy.py#L329>`_"
" for an example."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:390
msgid "_ansible_no_log"
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:392
msgid ""
"Boolean. Set to True whenever a parameter in a task or play specifies "
"``no_log``. Any module that calls :py:meth:`AnsibleModule.log` handles "
"this automatically. If a module implements its own logging then it needs "
"to check this value. To access in a module, instantiate an "
"``AnsibleModule`` and then check the value of "
":attr:`AnsibleModule.no_log`."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:397
msgid ""
"``no_log`` specified in a module's argument_spec is handled by a "
"different mechanism."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:400
msgid "_ansible_debug"
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:402
msgid ""
"Boolean. Turns more verbose logging on or off and turns on logging of "
"external commands that the module executes. If a module uses "
":py:meth:`AnsibleModule.debug` rather than :py:meth:`AnsibleModule.log` "
"then the messages are only logged if ``_ansible_debug`` is set to "
"``True``. To set, add ``debug: True`` to :file:`ansible.cfg` or set the "
"environment variable :envvar:`ANSIBLE_DEBUG`. To access in a module, "
"instantiate an ``AnsibleModule`` and access :attr:`AnsibleModule._debug`."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:411
msgid "_ansible_diff"
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:413
msgid ""
"Boolean. If a module supports it, tells the module to show a unified diff"
" of changes to be made to templated files. To set, pass the ``--diff`` "
"command line option. To access in a module, instantiate an "
"`AnsibleModule` and access :attr:`AnsibleModule._diff`."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:419
msgid "_ansible_verbosity"
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:421
msgid "Unused. This value could be used for finer grained control over logging."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:424
msgid "_ansible_selinux_special_fs"
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:426
msgid ""
"List. Names of filesystems which should have a special SELinux context. "
"They are used by the `AnsibleModule` methods which operate on files "
"(changing attributes, moving, and copying). To set, add a comma separated"
" string of filesystem names in :file:`ansible.cfg`::"
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:434
msgid ""
"Most modules can use the built-in ``AnsibleModule`` methods to manipulate"
" files. To access in a module that needs to know about these special "
"context filesystems, instantiate an ``AnsibleModule`` and examine the "
"list in :attr:`AnsibleModule._selinux_special_fs`."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:438
msgid ""
"This replaces :attr:`ansible.module_utils.basic.SELINUX_SPECIAL_FS` from "
":ref:`module_replacer`. In module replacer it was a comma separated "
"string of filesystem names. Under Ansiballz it's an actual list."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:445
msgid "_ansible_syslog_facility"
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:447
msgid ""
"This parameter controls which syslog facility Ansible module logs to. To "
"set, change the ``syslog_facility`` value in :file:`ansible.cfg`. Most "
"modules should just use :meth:`AnsibleModule.log` which will then make "
"use of this. If a module has to use this on its own, it should "
"instantiate an `AnsibleModule` and then retrieve the name of the syslog "
"facility from :attr:`AnsibleModule._syslog_facility`. The Ansiballz code "
"is less hacky than the old :ref:`module_replacer` code:"
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:468
msgid "_ansible_version"
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:470
msgid ""
"This parameter passes the version of Ansible that runs the module. To "
"access it, a module should instantiate an `AnsibleModule` and then "
"retrieve it from :attr:`AnsibleModule.ansible_version`. This replaces "
":attr:`ansible.module_utils.basic.ANSIBLE_VERSION` from "
":ref:`module_replacer`."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:482
msgid "Module return values & Unsafe strings"
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:484
msgid ""
"At the end of a module's execution, it formats the data that it wants to "
"return as a JSON string and prints the string to its stdout. The normal "
"action plugin receives the JSON string, parses it into a Python "
"dictionary, and returns it to the executor."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:486
msgid ""
"If Ansible templated every string return value, it would be vulnerable to"
" an attack from users with access to managed nodes. If an unscrupulous "
"user disguised malicious code as Ansible return value strings, and if "
"those strings were then templated on the controller, Ansible could "
"execute arbitrary code. To prevent this scenario, Ansible marks all "
"strings inside returned data as ``Unsafe``, emitting any Jinja2 templates"
" in the strings verbatim, not expanded by Jinja2."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:488
msgid ""
"Strings returned by invoking a module through "
"``ActionPlugin._execute_module()`` are automatically marked as ``Unsafe``"
" by the normal action plugin. If another action plugin retrieves "
"information from a module through some other means, it must mark its "
"return data as ``Unsafe`` on its own."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:490
msgid ""
"In case a poorly-coded action plugin fails to mark its results as "
"\"Unsafe,\" Ansible audits the results again when they are returned to "
"the executor, marking all strings as ``Unsafe``. The normal action plugin"
" protects itself and any other code that it calls with the result data as"
" a parameter. The check inside the executor protects the output of all "
"other action plugins, ensuring that subsequent tasks run by Ansible will "
"not template anything from those results either."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:496
msgid "Special considerations"
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:501
msgid "Pipelining"
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:503
msgid "Ansible can transfer a module to a remote machine in one of two ways:"
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:505
msgid ""
"it can write out the module to a temporary file on the remote host and "
"then use a second connection to the remote host to execute it with the "
"interpreter that the module needs"
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:508
msgid ""
"or it can use what's known as pipelining to execute the module by piping "
"it into the remote interpreter's stdin."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:511
msgid ""
"Pipelining only works with modules written in Python at this time because"
" Ansible only knows that Python supports this mode of operation. "
"Supporting pipelining means that whatever format the module payload takes"
" before being sent over the wire must be executable by Python via stdin."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:519
msgid "Why pass args over stdin?"
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:521
msgid "Passing arguments via stdin was chosen for the following reasons:"
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:523
msgid ""
"When combined with :ref:`ANSIBLE_PIPELINING`, this keeps the module's "
"arguments from temporarily being saved onto disk on the remote machine. "
"This makes it harder (but not impossible) for a malicious user on the "
"remote machine to steal any sensitive information that may be present in "
"the arguments."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:527
msgid ""
"Command line arguments would be insecure as most systems allow "
"unprivileged users to read the full commandline of a process."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:529
msgid ""
"Environment variables are usually more secure than the commandline but "
"some systems limit the total size of the environment. This could lead to "
"truncation of the parameters if we hit that limit."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:537
msgid "AnsibleModule"
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:542
msgid "Argument spec"
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:544
msgid ""
"The ``argument_spec`` provided to ``AnsibleModule`` defines the supported"
" arguments for a module, as well as their type, defaults and more."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:546
msgid "Example ``argument_spec``:"
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:562
msgid "This section will discuss the behavioral attributes for arguments:"
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:565
msgid "type"
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:567
msgid ""
"``type`` allows you to define the type of the value accepted for the "
"argument. The default value for ``type`` is ``str``. Possible values are:"
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:569
msgid "str"
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:570
msgid "list"
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:571
msgid "dict"
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:572
msgid "bool"
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:573
msgid "int"
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:574
msgid "float"
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:575
msgid "path"
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:576
msgid "raw"
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:577
msgid "jsonarg"
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:578
msgid "json"
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:579
msgid "bytes"
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:580
msgid "bits"
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:582
msgid ""
"The ``raw`` type, performs no type validation or type casing, and "
"maintains the type of the passed value."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:585
msgid "elements"
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:587
msgid ""
"``elements`` works in combination with ``type`` when ``type='list'``. "
"``elements`` can then be defined as ``elements='int'`` or any other type,"
" indicating that each element of the specified list should be of that "
"type."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:590
msgid "default"
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:592
msgid ""
"The ``default`` option allows sets a default value for the argument for "
"the scenario when the argument is not provided to the module. When not "
"specified, the default value is ``None``."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:595
msgid "fallback"
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:597
msgid ""
"``fallback`` accepts a ``tuple`` where the first argument is a callable "
"(function) that will be used to perform the lookup, based on the second "
"argument. The second argument is a list of values to be accepted by the "
"callable."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:599
msgid ""
"The most common callable used is ``env_fallback`` which will allow an "
"argument to optionally use an environment variable when the argument is "
"not supplied."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:601
msgid "Example::"
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:606
msgid "choices"
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:608
msgid ""
"``choices`` accepts a list of choices that the argument will accept. The "
"types of ``choices`` should match the ``type``."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:611
msgid "required"
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:613
msgid ""
"``required`` accepts a boolean, either ``True`` or ``False`` that "
"indicates that the argument is required. This should not be used in "
"combination with ``default``."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:616
msgid "no_log"
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:618
msgid ""
"``no_log`` indicates that the value of the argument should not be logged "
"or displayed."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:621
msgid "aliases"
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:623
msgid ""
"``aliases`` accepts a list of alternative argument names for the "
"argument, such as the case where the argument is ``name`` but the module "
"accepts ``aliases=['pkg']`` to allow ``pkg`` to be interchangeably with "
"``name``"
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:626
msgid "options"
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:628
msgid ""
"``options`` implements the ability to create a sub-argument_spec, where "
"the sub options of the top level argument are also validated using the "
"attributes discussed in this section. The example at the top of this "
"section demonstrates use of ``options``. ``type`` or ``elements`` should "
"be ``dict`` is this case."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:631
msgid "apply_defaults"
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:633
msgid ""
"``apply_defaults`` works alongside ``options`` and allows the ``default``"
" of the sub-options to be applied even when the top-level argument is not"
" supplied."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:635
msgid ""
"In the example of the ``argument_spec`` at the top of this section, it "
"would allow ``module.params['top_level']['second_level']`` to be defined,"
" even if the user does not provide ``top_level`` when calling the module."
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:638
msgid "removed_in_version"
msgstr ""

#: ../../rst/dev_guide/developing_program_flow_modules.rst:640
msgid ""
"``removed_in_version`` indicates which version of Ansible a deprecated "
"argument will be removed in."
msgstr ""

#~ msgid ""
#~ "This in-depth dive helps you "
#~ "understand Ansible's program flow to "
#~ "execute modules. It is written for "
#~ "people working on the portions of "
#~ "the Core Ansible Engine that execute "
#~ "a module. Those writing Ansible Modules"
#~ " may also find this in-depth "
#~ "dive to be of interest, but "
#~ "individuals simply using Ansible Modules "
#~ "will not likely find this to be"
#~ " helpful."
#~ msgstr ""

#~ msgid "Topics"
#~ msgstr ""

#~ msgid ""
#~ "Ansible supports several different types "
#~ "of modules in its code base.  Some"
#~ " of these are for backwards "
#~ "compatibility and others are to enable"
#~ " flexibility."
#~ msgstr ""

#~ msgid ""
#~ "Action Plugins look like modules to "
#~ "end users who are writing "
#~ ":term:`playbooks` but they're distinct "
#~ "entities for the purposes of this "
#~ "document.  Action Plugins always execute "
#~ "on the controller and are sometimes "
#~ "able to do all work there (for "
#~ "instance, the ``debug`` Action Plugin "
#~ "which prints some text for the "
#~ "user to see or the ``assert`` "
#~ "Action Plugin which can test whether "
#~ "several values in a playbook satisfy "
#~ "certain criteria.)"
#~ msgstr ""

#~ msgid ""
#~ "More often, Action Plugins set up "
#~ "some values on the controller, then "
#~ "invoke an actual module on the "
#~ "managed node that does something with"
#~ " these values.  An easy to understand"
#~ " version of this is the "
#~ ":ref:`template Action Plugin <template_module>`."
#~ "  The :ref:`template Action Plugin "
#~ "<template_module>` takes values from the "
#~ "user to construct a file in a "
#~ "temporary location on the controller "
#~ "using variables from the playbook "
#~ "environment.  It then transfers the "
#~ "temporary file to a temporary file "
#~ "on the remote system.  After that, "
#~ "it invokes the :ref:`copy module "
#~ "<copy_module>` which operates on the "
#~ "remote system to move the file "
#~ "into its final location, sets file "
#~ "permissions, and so on."
#~ msgstr ""

#~ msgid "All of the modules that ship with Ansible fall into this category."
#~ msgstr ""

#~ msgid ""
#~ "New-style modules have the arguments "
#~ "to the module embedded inside of "
#~ "them in some manner.  Non-new-"
#~ "style modules must copy a separate "
#~ "file over to the managed node, "
#~ "which is less efficient as it "
#~ "requires two over-the-wire connections"
#~ " instead of only one."
#~ msgstr ""

#~ msgid ""
#~ "New-style Python modules use the "
#~ ":ref:`Ansiballz` framework for constructing "
#~ "modules.  All official modules (shipped "
#~ "with Ansible) use either this or "
#~ "the :ref:`powershell module framework "
#~ "<flow_powershell_modules>`."
#~ msgstr ""

#~ msgid ""
#~ "These modules use imports from "
#~ ":code:`ansible.module_utils` in order to pull"
#~ " in boilerplate module code, such as"
#~ " argument parsing, formatting of return "
#~ "values as :term:`JSON`, and various file"
#~ " operations."
#~ msgstr ""

#~ msgid "Powershell"
#~ msgstr ""

#~ msgid ""
#~ "New-style powershell modules use the "
#~ ":ref:`module_replacer` framework for constructing"
#~ " modules.  These modules get a "
#~ "library of powershell code embedded in"
#~ " them before being sent to the "
#~ "managed node."
#~ msgstr ""

#~ msgid "JSONARGS"
#~ msgstr ""

#~ msgid ""
#~ "Scripts can arrange for an argument "
#~ "string to be placed within them by"
#~ " placing the string "
#~ "``<<INCLUDE_ANSIBLE_MODULE_JSON_ARGS>>`` somewhere inside"
#~ " of the file.  The module typically"
#~ " sets a variable to that value "
#~ "like this:"
#~ msgstr ""

#~ msgid ""
#~ "Ansible outputs a :term:`JSON` string "
#~ "with bare quotes.  Double quotes are "
#~ "used to quote string values, double "
#~ "quotes inside of string values are "
#~ "backslash escaped, and single quotes may"
#~ " appear unescaped inside of a string"
#~ " value.  To use JSONARGS, your "
#~ "scripting language must have a way "
#~ "to handle this type of string.  "
#~ "The example uses Python's triple quoted"
#~ " strings to do this.  Other scripting"
#~ " languages may have a similar quote"
#~ " character that won't be confused by"
#~ " any quotes in the JSON or it"
#~ " may allow you to define your "
#~ "own start-of-quote and end-of-"
#~ "quote characters. If the language "
#~ "doesn't give you any of these then"
#~ " you'll need to write a :ref:`non-"
#~ "native JSON module <flow_want_json_modules>` "
#~ "or :ref:`Old-style module "
#~ "<flow_old_style_modules>` instead."
#~ msgstr ""

#~ msgid ""
#~ "The module typically parses the contents"
#~ " of ``json_arguments`` using a JSON "
#~ "library and then use them as "
#~ "native variables throughout the rest of"
#~ " its code."
#~ msgstr ""

#~ msgid ""
#~ "If a module has the string "
#~ "``WANT_JSON`` in it anywhere, Ansible "
#~ "treats it as a non-native module"
#~ " that accepts a filename as its "
#~ "only command line parameter.  The "
#~ "filename is for a temporary file "
#~ "containing a :term:`JSON` string containing"
#~ " the module's parameters.  The module "
#~ "needs to open the file, read and"
#~ " parse the parameters, operate on the"
#~ " data, and print its return data "
#~ "as a JSON encoded dictionary to "
#~ "stdout before exiting."
#~ msgstr ""

#~ msgid ""
#~ "These types of modules are self-"
#~ "contained entities.  As of Ansible 2.1,"
#~ " Ansible only modifies them to change"
#~ " a shebang line if present."
#~ msgstr ""

#~ msgid ""
#~ "From Ansible 2.2 onwards, modules may"
#~ " also be small binary programs.  "
#~ "Ansible doesn't perform any magic to "
#~ "make these portable to different systems"
#~ " so they may be specific to the"
#~ " system on which they were compiled"
#~ " or require other binary runtime "
#~ "dependencies.  Despite these drawbacks, a "
#~ "site may sometimes have no choice "
#~ "but to compile a custom module "
#~ "against a specific binary library if "
#~ "that's the only way they have to"
#~ " get access to certain resources."
#~ msgstr ""

#~ msgid ""
#~ "Binary modules take their arguments and"
#~ " will return data to Ansible in "
#~ "the same way as :ref:`want JSON "
#~ "modules <flow_want_json_modules>`."
#~ msgstr ""

#~ msgid ""
#~ "Old-style modules are similar to "
#~ ":ref:`want JSON modules <flow_want_json_modules>`,"
#~ " except that the file that they "
#~ "take contains ``key=value`` pairs for "
#~ "their parameters instead of :term:`JSON`."
#~ msgstr ""

#~ msgid ""
#~ "Ansible decides that a module is "
#~ "old-style when it doesn't have any"
#~ " of the markers that would show "
#~ "that it is one of the other "
#~ "types."
#~ msgstr ""

#~ msgid ""
#~ "When a user uses :program:`ansible` or"
#~ " :program:`ansible-playbook`, they specify "
#~ "a task to execute.  The task is"
#~ " usually the name of a module "
#~ "along with several parameters to be "
#~ "passed to the module.  Ansible takes "
#~ "these values and processes them in "
#~ "various ways before they are finally "
#~ "executed on the remote machine."
#~ msgstr ""

#~ msgid ""
#~ "The TaskExecutor receives the module "
#~ "name and parameters that were parsed "
#~ "from the :term:`playbook <playbooks>` (or "
#~ "from the command line in the case"
#~ " of :command:`/usr/bin/ansible`).  It uses "
#~ "the name to decide whether it's "
#~ "looking at a module or an "
#~ ":ref:`Action Plugin <flow_action_plugins>`.  If "
#~ "it's a module, it loads the "
#~ ":ref:`Normal Action Plugin "
#~ "<flow_normal_action_plugin>` and passes the "
#~ "name, variables, and other information "
#~ "about the task and play to that"
#~ " Action Plugin for further processing."
#~ msgstr ""

#~ msgid "Normal action plugin"
#~ msgstr ""

#~ msgid ""
#~ "The ``normal`` action plugin executes "
#~ "the module on the remote host.  It"
#~ " is the primary coordinator of much"
#~ " of the work to actually execute "
#~ "the module on the managed machine."
#~ msgstr ""

#~ msgid ""
#~ "It takes care of creating a "
#~ "connection to the managed machine by "
#~ "instantiating a ``Connection`` class according"
#~ " to the inventory configuration for "
#~ "that host."
#~ msgstr ""

#~ msgid ""
#~ "It adds any internal Ansible variables"
#~ " to the module's parameters (for "
#~ "instance, the ones that pass along "
#~ "``no_log`` to the module)."
#~ msgstr ""

#~ msgid ""
#~ "It takes care of creating any "
#~ "temporary files on the remote machine"
#~ " and cleans up afterwards."
#~ msgstr ""

#~ msgid ""
#~ "It does the actual work of pushing"
#~ " the module and module parameters to"
#~ " the remote host, although the "
#~ ":ref:`module_common <flow_executor_module_common>` code"
#~ " described in the next section does"
#~ " the work of deciding which format"
#~ " those will take."
#~ msgstr ""

#~ msgid ""
#~ "It handles any special cases regarding"
#~ " modules (for instance, various "
#~ "complications around Windows modules that "
#~ "must have the same names as Python"
#~ " modules, so that internal calling of"
#~ " modules from other Action Plugins "
#~ "work.)"
#~ msgstr ""

#~ msgid ""
#~ "Much of this functionality comes from"
#~ " the `BaseAction` class, which lives "
#~ "in :file:`plugins/action/__init__.py`.  It makes "
#~ "use of ``Connection`` and ``Shell`` "
#~ "objects to do its work."
#~ msgstr ""

#~ msgid ""
#~ "When :term:`tasks <tasks>` are run with"
#~ " the ``async:`` parameter, Ansible uses "
#~ "the ``async`` Action Plugin instead of"
#~ " the ``normal`` Action Plugin to "
#~ "invoke it.  That program flow is "
#~ "currently not documented.  Read the "
#~ "source for information on how that "
#~ "works."
#~ msgstr ""

#~ msgid ""
#~ "Code in :file:`executor/module_common.py` takes "
#~ "care of assembling the module to "
#~ "be shipped to the managed node.  "
#~ "The module is first read in, then"
#~ " examined to determine its type.  "
#~ ":ref:`PowerShell <flow_powershell_modules>` and :ref"
#~ ":`JSON-args modules <flow_jsonargs_modules>` are"
#~ " passed through :ref:`Module Replacer "
#~ "<module_replacer>`.  New-style :ref:`Python "
#~ "modules <flow_python_modules>` are assembled "
#~ "by :ref:`Ansiballz`. :ref:`Non-native-want-"
#~ "JSON <flow_want_json_modules>`, :ref:`Binary modules"
#~ " <flow_binary_modules>`, and :ref:`Old-Style "
#~ "modules <flow_old_style_modules>` aren't touched "
#~ "by either of these and pass "
#~ "through unchanged.  After the assembling "
#~ "step, one final modification is made "
#~ "to all modules that have a shebang"
#~ " line.  Ansible checks whether the "
#~ "interpreter in the shebang line has "
#~ "a specific path configured via an "
#~ "``ansible_$X_interpreter`` inventory variable.  If"
#~ " it does, Ansible substitutes that "
#~ "path for the interpreter path given "
#~ "in the module.  After this, Ansible "
#~ "returns the complete module data and "
#~ "the module type to the :ref:`Normal "
#~ "Action <flow_normal_action_plugin>` which continues"
#~ " execution of the module."
#~ msgstr ""

#~ msgid "Next we'll go into some details of the two assembler frameworks."
#~ msgstr ""

#~ msgid ""
#~ "The Module Replacer framework is the "
#~ "original framework implementing new-style "
#~ "modules.  It is essentially a "
#~ "preprocessor (like the C Preprocessor "
#~ "for those familiar with that programming"
#~ " language).  It does straight substitutions"
#~ " of specific substring patterns in "
#~ "the module file.  There are two "
#~ "types of substitutions:"
#~ msgstr ""

#~ msgid ""
#~ "Replacements that only happen in the "
#~ "module file.  These are public "
#~ "replacement strings that modules can "
#~ "utilize to get helpful boilerplate or"
#~ " access to arguments."
#~ msgstr ""

#~ msgid ""
#~ ":code:`# POWERSHELL_COMMON` substitutes the "
#~ "contents of :file:`ansible/module_utils/powershell.ps1`."
#~ "  It should only be used with "
#~ ":ref:`new-style Powershell modules "
#~ "<flow_powershell_modules>`."
#~ msgstr ""

#~ msgid ""
#~ "Replacements that are used by "
#~ "``ansible.module_utils`` code.  These are "
#~ "internal replacement patterns.  They may "
#~ "be used internally, in the above "
#~ "public replacements, but shouldn't be "
#~ "used directly by modules."
#~ msgstr ""

#~ msgid ""
#~ ":code:`\"<<INCLUDE_ANSIBLE_MODULE_COMPLEX_ARGS>>\"` is "
#~ "substituted with a string which is "
#~ "the Python ``repr`` of the :term:`JSON`"
#~ " encoded module parameters.  Using ``repr``"
#~ " on the JSON string makes it "
#~ "safe to embed in a Python file."
#~ "  In new-style Python modules under"
#~ " the Ansiballz framework this is "
#~ "better accessed by instantiating an "
#~ "`AnsibleModule` and then using "
#~ ":attr:`AnsibleModule.params`."
#~ msgstr ""

#~ msgid ""
#~ ":code:`<<SELINUX_SPECIAL_FILESYSTEMS>>` substitutes a "
#~ "string which is a comma separated "
#~ "list of file systems which have a"
#~ " file system dependent security context "
#~ "in SELinux.  In new-style Python "
#~ "modules, if you really need this "
#~ "you should instantiate an `AnsibleModule` "
#~ "and then use "
#~ ":attr:`AnsibleModule._selinux_special_fs`.  The variable"
#~ " has also changed from a comma "
#~ "separated string of file system names"
#~ " to an actual python list of "
#~ "filesystem names."
#~ msgstr ""

#~ msgid ""
#~ ":code:`<<INCLUDE_ANSIBLE_MODULE_JSON_ARGS>>` substitutes "
#~ "the module parameters as a JSON "
#~ "string.  Care must be taken to "
#~ "properly quote the string as JSON "
#~ "data may contain quotes.  This pattern"
#~ " is not substituted in new-style "
#~ "Python modules as they can get the"
#~ " module parameters another way."
#~ msgstr ""

#~ msgid ""
#~ "The string :code:`syslog.LOG_USER` is replaced"
#~ " wherever it occurs with the "
#~ "``syslog_facility`` which was named in "
#~ ":file:`ansible.cfg` or any "
#~ "``ansible_syslog_facility`` inventory variable that"
#~ " applies to this host.  In new-"
#~ "style Python modules this has changed"
#~ " slightly.  If you really need to "
#~ "access it, you should instantiate an "
#~ "`AnsibleModule` and then use "
#~ ":attr:`AnsibleModule._syslog_facility` to access it."
#~ "  It is no longer the actual "
#~ "syslog facility and is now the "
#~ "name of the syslog facility.  See "
#~ "the :ref:`documentation on internal arguments"
#~ " <flow_internal_arguments>` for details."
#~ msgstr ""

#~ msgid ""
#~ "Ansible 2.1 switched from the "
#~ ":ref:`module_replacer` framework to the "
#~ "Ansiballz framework for assembling modules."
#~ "  The Ansiballz framework differs from "
#~ "module replacer in that it uses "
#~ "real Python imports of things in "
#~ ":file:`ansible/module_utils` instead of merely "
#~ "preprocessing the module.  It does this"
#~ " by constructing a zipfile -- which"
#~ " includes the module file, files in"
#~ " :file:`ansible/module_utils` that are imported"
#~ " by the module, and some boilerplate"
#~ " to pass in the module's parameters."
#~ "  The zipfile is then Base64 encoded"
#~ " and wrapped in a small Python "
#~ "script which decodes the Base64 encoding"
#~ " and places the zipfile into a "
#~ "temp directory on the managed node.  "
#~ "It then extracts just the ansible "
#~ "module script from the zip file "
#~ "and places that in the temporary "
#~ "directory as well.  Then it sets "
#~ "the PYTHONPATH to find python modules"
#~ " inside of the zip file and "
#~ "invokes :command:`python` on the extracted "
#~ "ansible module."
#~ msgstr ""

#~ msgid ""
#~ "so that pipelining will function "
#~ "properly.  Pipelining needs to pipe the"
#~ " Python module into the Python "
#~ "interpreter on the remote node.  Python"
#~ " understands scripts on stdin but "
#~ "does not understand zip files."
#~ msgstr ""

#~ msgid ""
#~ "In Ansiballz, any imports of Python "
#~ "modules from the :py:mod:`ansible.module_utils` "
#~ "package trigger inclusion of that Python"
#~ " file into the zipfile.  Instances of"
#~ " :code:`#<<INCLUDE_ANSIBLE_MODULE_COMMON>>` in the "
#~ "module are turned into :code:`from "
#~ "ansible.module_utils.basic import *` and "
#~ ":file:`ansible/module-utils/basic.py` is then "
#~ "included in the zipfile. Files that "
#~ "are included from :file:`module_utils` are "
#~ "themselves scanned for imports of other"
#~ " Python modules from :file:`module_utils` "
#~ "to be included in the zipfile as"
#~ " well."
#~ msgstr ""

#~ msgid ""
#~ "At present, the Ansiballz Framework "
#~ "cannot determine whether an import "
#~ "should be included if it is a "
#~ "relative import.  Always use an absolute"
#~ " import that has :py:mod:`ansible.module_utils`"
#~ " in it to allow Ansiballz to "
#~ "determine that the file should be "
#~ "included."
#~ msgstr ""

#~ msgid ""
#~ "In :ref:`module_replacer`, module arguments "
#~ "are turned into a JSON-ified "
#~ "string and substituted into the combined"
#~ " module file.  In :ref:`Ansiballz`, the "
#~ "JSON-ified string is passed into "
#~ "the module via stdin.  When a  "
#~ ":class:`ansible.module_utils.basic.AnsibleModule` is "
#~ "instantiated, it parses this string and"
#~ " places the args into "
#~ ":attr:`AnsibleModule.params` where it can be"
#~ " accessed by the module's other code."
#~ msgstr ""

#~ msgid ""
#~ "Internally, the `AnsibleModule` uses the "
#~ "helper function, "
#~ ":py:func:`ansible.module_utils.basic._load_params`, to "
#~ "load the parameters from stdin and "
#~ "save them into an internal global "
#~ "variable.  Very dynamic custom modules "
#~ "which need to parse the parameters "
#~ "prior to instantiating an ``AnsibleModule``"
#~ " may use ``_load_params`` to retrieve "
#~ "the parameters.  Be aware that "
#~ "``_load_params`` is an internal function "
#~ "and may change in breaking ways if"
#~ " necessary to support changes in the"
#~ " code. However, we'll do our best "
#~ "not to break it gratuitously, which "
#~ "is not something that can be said"
#~ " for either the way parameters are"
#~ " passed or the internal global "
#~ "variable."
#~ msgstr ""

#~ msgid ""
#~ "Both :ref:`module_replacer` and :ref:`Ansiballz` "
#~ "send additional arguments to the module"
#~ " beyond those which the user "
#~ "specified in the playbook.  These "
#~ "additional arguments are internal parameters"
#~ " that help implement global Ansible "
#~ "features.  Modules often do not need "
#~ "to know about these explicitly as "
#~ "the features are implemented in "
#~ ":py:mod:`ansible.module_utils.basic` but certain "
#~ "features need support from the module"
#~ " so it's good to know about "
#~ "them."
#~ msgstr ""

#~ msgid ""
#~ "This is a boolean.  If it's True"
#~ " then the playbook specified ``no_log`` "
#~ "(in a task's parameters or as a"
#~ " play parameter).  This automatically "
#~ "affects calls to :py:meth:`AnsibleModule.log`.  "
#~ "If a module implements its own "
#~ "logging then it needs to check "
#~ "this value.  The best way to look"
#~ " at this is for the module to"
#~ " instantiate an `AnsibleModule` and then"
#~ " check the value of "
#~ ":attr:`AnsibleModule.no_log`."
#~ msgstr ""

#~ msgid ""
#~ "``no_log`` specified in a module's "
#~ "argument_spec are handled by a different"
#~ " mechanism."
#~ msgstr ""

#~ msgid ""
#~ "This is a boolean that turns on"
#~ " more verbose logging.  If a module"
#~ " uses :py:meth:`AnsibleModule.debug` rather than"
#~ " :py:meth:`AnsibleModule.log` then the messages"
#~ " are only logged if this is "
#~ "True.  This also turns on logging "
#~ "of external commands that the module "
#~ "executes.  This can be changed via "
#~ "the ``debug`` setting in :file:`ansible.cfg`"
#~ " or the environment variable "
#~ ":envvar:`ANSIBLE_DEBUG`.  If, for some reason,"
#~ " a module must access this, it "
#~ "should do so by instantiating an "
#~ "`AnsibleModule` and accessing "
#~ ":attr:`AnsibleModule._debug`."
#~ msgstr ""

#~ msgid ""
#~ "This boolean is turned on via the"
#~ " ``--diff`` command line option.  If "
#~ "a module supports it, it will tell"
#~ " the module to show a unified "
#~ "diff of changes to be made to "
#~ "templated files.  The proper way for "
#~ "a module to access this is by "
#~ "instantiating an `AnsibleModule` and accessing"
#~ " :attr:`AnsibleModule._diff`."
#~ msgstr ""

#~ msgid ""
#~ "This value could be used for finer"
#~ " grained control over logging. However, "
#~ "it is currently unused."
#~ msgstr ""

#~ msgid ""
#~ "This is a list of names of "
#~ "filesystems which should have a special"
#~ " selinux context.  They are used by"
#~ " the `AnsibleModule` methods which operate"
#~ " on files (changing attributes, moving, "
#~ "and copying).  The list of names "
#~ "is set via a comma separated "
#~ "string of filesystem names from "
#~ ":file:`ansible.cfg`::"
#~ msgstr ""

#~ msgid ""
#~ "If a module cannot use the builtin"
#~ " ``AnsibleModule`` methods to manipulate "
#~ "files and needs to know about "
#~ "these special context filesystems, it "
#~ "should instantiate an ``AnsibleModule`` and"
#~ " then examine the list in "
#~ ":attr:`AnsibleModule._selinux_special_fs`."
#~ msgstr ""

#~ msgid ""
#~ "This replaces "
#~ ":attr:`ansible.module_utils.basic.SELINUX_SPECIAL_FS` from "
#~ ":ref:`module_replacer`.  In module replacer it"
#~ " was a comma separated string of "
#~ "filesystem names.  Under Ansiballz it's "
#~ "an actual list."
#~ msgstr ""

#~ msgid ""
#~ "This parameter controls which syslog "
#~ "facility ansible module logs to.  It "
#~ "may be set by changing the "
#~ "``syslog_facility`` value in :file:`ansible.cfg`."
#~ "  Most modules should just use "
#~ ":meth:`AnsibleModule.log` which will then make"
#~ " use of this.  If a module has"
#~ " to use this on its own, it "
#~ "should instantiate an `AnsibleModule` and "
#~ "then retrieve the name of the "
#~ "syslog facility from "
#~ ":attr:`AnsibleModule._syslog_facility`.  The code "
#~ "will look slightly different than it "
#~ "did under :ref:`module_replacer` due to "
#~ "how hacky the old way was"
#~ msgstr ""

#~ msgid ""
#~ "This parameter passes the version of "
#~ "ansible that runs the module.  To "
#~ "access it, a module should instantiate"
#~ " an `AnsibleModule` and then retrieve "
#~ "it from :attr:`AnsibleModule.ansible_version`.  This"
#~ " replaces :attr:`ansible.module_utils.basic.ANSIBLE_VERSION`"
#~ " from :ref:`module_replacer`."
#~ msgstr ""

#~ msgid ""
#~ "Pipelining only works with modules "
#~ "written in Python at this time "
#~ "because Ansible only knows that Python"
#~ " supports this mode of operation.  "
#~ "Supporting pipelining means that whatever "
#~ "format the module payload takes before"
#~ " being sent over the wire must "
#~ "be executable by Python via stdin."
#~ msgstr ""

#~ msgid ""
#~ "When combined with :ref:`ANSIBLE_PIPELINING`, "
#~ "this keeps the module's arguments from"
#~ " temporarily being saved onto disk on"
#~ " the remote machine.  This makes it"
#~ " harder (but not impossible) for a"
#~ " malicious user on the remote machine"
#~ " to steal any sensitive information "
#~ "that may be present in the "
#~ "arguments."
#~ msgstr ""

#~ msgid ""
#~ "Environment variables are usually more "
#~ "secure than the commandline but some "
#~ "systems limit the total size of "
#~ "the environment.  This could lead to "
#~ "truncation of the parameters if we "
#~ "hit that limit."
#~ msgstr ""

#~ msgid ""
#~ "``aliases`` accepts a list of "
#~ "alternative argument names for the "
#~ "argument, such as the case where "
#~ "the argument is ``name`` but the "
#~ "module accepts ``aliases=['pkg']`` to allow"
#~ " ``pkg`` to be interchangably with "
#~ "``name``"
#~ msgstr ""

